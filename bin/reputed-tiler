#!/bin/bash
# vim:tw=0:ts=2:sw=2:et:ft=sh:

# [lb]: quicktile broken in tara/bionic/18.04:
#
#   https://github.com/ssokolow/quicktile/issues/95
#
# Fortunately, I found a very capable, hackable replacement.
#
# - "Crude quarter tiling tool"
#
#   https://gist.github.com/peteruithoven/db0cba0b0849c8cb5e267f6e75126304

# ***

#LOGFILE=$(mktemp -du)
LOGFILE=/tmp/reputed-tiler-tmp.LAcwQ6zU4P
echo -e "Logging to:\n  ${LOGFILE}"

source "${HOME}/.fries/lib/logger.sh"

log () {
  debug "$@" >> ${LOGFILE}
}

# ***

before_command () {
  FRIES__CMDNAME="reputed-tiler"
  FRIES__VERSION=0.0.1

  ORIG_OFFSET_GEOM=""
}

after_command () {
  unset FRIES__CMDNAME
  unset FRIES__VERSION

  unset ORIG_OFFSET_GEOM
}

print_version_and_exit () {
  # Use hard coded name, not $0, which is 'bash' when file is sourced.
  >&2 echo "${FRIES__CMDNAME} version ${FRIES__VERSION}"
  exit 0
}

print_help_and_exit () {
  >&2 echo "Usage: ${FRIES__CMDNAME} [-v|--version] [-h|--help] <name>"
  >&2 echo "See \`man ${FRIES__CMDNAME}\` for more help"
  exit 0
}

parse_first_positional () {
  local first_one=''
  local skip_opts=false
  while [[ "$1" != '' ]]; do
    if [[ "$1" == '--' ]]; then
      skip_opts=true
      shift
      continue
    elif ! ${skip_opts}; then
      case $1 in
        -v)
          print_version_and_exit
          ;;
        --version)
          print_version_and_exit
          ;;
        -h)
          print_help_and_exit
          ;;
        --help)
          print_help_and_exit
          ;;
      esac
    fi
    if [[ -z ${first_one} ]]; then
      first_one=$1
    fi
    shift
  done
  if [[ -z ${first_one} ]]; then
    >&2 echo 'Missing one of: left|up|right|down'
    exit 2
  fi
  echo "${first_one}"
}

# ***

must_be_known_direction () {
  case "$1" in
    left)
      ;;
    top)
      ;&
    up)
      ;;
    right)
      ;;
    bottom)
      ;&
    down)
      ;;
    *)
      >&2 echo "Unrecognized direction: “${1}”"
      exit 2
      ;;
  esac
}

# ***

active_window_offset_geom () {
  # [lb]: MAYBE/2019-01-04: Will "Position" always have "screen" ending?
  #
  #   $ xdotool getwindowfocus getwindowgeometry
  #   Window 54908756
  #     Position: 332,234 (screen: 0)
  #     Geometry: 1334x529

  # Use either xdotool or xwininfo to get the active window's digits, e.g.,
  #
  #   xdotool getwindowfocus getwindowgeometry
  #
  # or
  #
  #   xwininfo -id $(xdotool getactivewindow)

  local OLD_IFS=$IFS

  # ***

  local position=()
  local position_xy
  position_xy=$( \
    xdotool getwindowfocus getwindowgeometry | \
      grep "^  Position:" | \
      sed "s%^  Position: \([^ ]\+\) .*%\1%" \
  )
  IFS=','
  read -ra position <<< ${position_xy}

  #log "position_xy: ${position_xy}"
  #log "position[0]: ${position[0]}"
  #log "position[1]: ${position[1]}"

  # ***

  local geometry=()
  local geometry_wh
  geometry_wh="$( \
    xdotool getwindowfocus getwindowgeometry | \
      grep "^  Geometry:" | \
      sed "s%^  Geometry: \(.*\)%\1%" \
  )"
  IFS='x'
  read -ra geometry <<< ${geometry_wh}

  #log "geometry_wh: ${geometry_wh}"
  #log "geometry[0]: ${geometry[0]}"
  #log "geometry[1]: ${geometry[1]}"

  # ***

  IFS=$OLD_IFS

  # ***

  local offset_geom
  offset_geom="${position[0]},${position[1]},${geometry[0]},${geometry[1]}"
  log "offset_geom: ${offset_geom}"
  echo "${offset_geom}"
}

# ***

read_last_used_direction () {
  local direction="$1"
  local repeatedn="0"
  # Look for the last command's dropping.
  local droppingf="${HOME}/.cache/${FRIES__CMDNAME}/cycles/${direction}"
  log "droppingf: ${droppingf}"
  log "  >> $(cat ${droppingf})"
  if [[ -f "${droppingf}" ]]; then
    local PARTS=()
    local OLD_IFS=$IFS
    IFS=' '
    read -ra PARTS <<< $(cat "${droppingf}")
    IFS=$OLD_IFS

    log "PARTS[0]: ${PARTS[0]}"
    log "PARTS[1]: ${PARTS[1]}"
    log "PARTS[2]: ${PARTS[2]}"
    log "PARTS[3]: ${PARTS[3]}"

    if [[ "${PARTS[1]}" -gt $(date -u '+%s' -d'1 minute ago') ]]; then
      local was_offsetgeo
      was_offsetgeo="${PARTS[2]}"
      log "was_offsetgeo: ${was_offsetgeo}"

      local cur_offsetgeo
      cur_offsetgeo="$(active_window_offset_geom)"
      log "cur_offsetgeo: ${cur_offsetgeo}"

      if [[ "${was_offsetgeo}" == "${cur_offsetgeo}" ]]; then
        repeatedn="$(( ${PARTS[0]} + 1 ))"
        log "repeatedn++: ${repeatedn}"

        ORIG_OFFSET_GEOM="${PARTS[4]}"
      fi
    fi
  fi
  if [[ -z "${ORIG_OFFSET_GEOM}" ]]; then
    # assert: [[ ${repeatedn} -eq 0 ]]
    ORIG_OFFSET_GEOM="$(active_window_offset_geom)"
  fi
  log "ORIG_OFFSET_GEOM: ${ORIG_OFFSET_GEOM}"
  echo "${repeatedn}"
}

record_last_used_direction () {
  local direction="$1"
  local repeatedn="$2"
#  local offsetgeo="$3"

  # Ensure the directory exists, e.g., ~/.cache/reputed-tiler
  /bin/mkdir -p ${HOME}/.cache/${FRIES__CMDNAME}/cycles

  # The offset and geometry we set may have shifted, depending on what else
  # is occupying the desktop, so don't use the result of determine_offsetgeo,
  # but refresh the actual window offset and geometry.
  #sleep 0.1s
  local offsetgeo
  offsetgeo="$(active_window_offset_geom)"

  # Leave a command dropping.
  echo -e "${repeatedn} $(date -u '+%s') ${offsetgeo} ${ORIG_OFFSET_GEOM}" > ${HOME}/.cache/${FRIES__CMDNAME}/cycles/${direction}
}

# ***

maybe_unset_maximized () {
  # When a window is maximized:
  #
  #   $ xprop -name 'abc' | grep _NET_WM_STATE
  #   _NET_WM_STATE(ATOM) = _NET_WM_STATE_MAXIMIZED_HORZ, _NET_WM_STATE_MAXIMIZED_VERT, _NET_WM_STATE_STICKY
  #
  # When not maximized:
  #
  #   $ xprop -name 'abc' | grep _NET_WM_STATE
  #   _NET_WM_STATE(ATOM) = _NET_WM_STATE_STICKY
  if $(xprop -id $(xdotool getactivewindow) | grep "_NET_WM_STATE.*MAXIMIZED" >/dev/null 2>&1); then
    # In case window is tiled by window manager, disable tilingg, for our reposition to work.
    wmctrl -r :ACTIVE: -b remove,maximized_vert
    # Wait for transition
    sleep 0.1s
  fi
}

# ***

determine_offsetgeo () {
  local direction="$1"
  local repeatedn="$2"


  # Margins around windows (elementary OS native apps) (HiDPI)
  MARGIN_TOP=130
  MARGIN_RIGHT=158
  MARGIN_BOTTOM=185
  MARGIN_LEFT=158
MARGIN_TOP=0
MARGIN_RIGHT=0
MARGIN_BOTTOM=0
MARGIN_LEFT=0

  # Desktops info
  #INFO=$(wmctrl -d | head -1)
  INFO=$(wmctrl -d | grep "\* DG")

  # Desktop size
  [[ $INFO =~ 'DG: '([0-9]+)'x'([0-9]+) ]]
  WIDTH=${BASH_REMATCH[1]}
  HEIGHT=${BASH_REMATCH[2]}

  # Available width height, and offsets see: $ wmctrl -d
  [[ $INFO =~ 'WA: '([0-9]+)','([0-9]+)' '([0-9]+)'x'([0-9]+) ]]
  OFFSET_X=${BASH_REMATCH[1]}
  OFFSET_Y=${BASH_REMATCH[2]}
  AV_WIDTH=${BASH_REMATCH[3]}
  AV_HEIGHT=${BASH_REMATCH[4]}

  log "D: ${WIDTH} x ${HEIGHT} / X,Y: ${OFFSET_X},${OFFSET_Y} / AV: ${AV_WIDTH} x ${AV_HEIGHT}"

# jchannon commented on Nov 8
# If you change monitors/resolutions this will fail slightly.
# Have amended the script to get the resolutions of the monitors below
#
#RESOLUTIONS=$(wmctrl -d | head -1 | awk '{x=$4"x"$9; print x}')
#j1=$(echo $RESOLUTIONS | cut -d'x' -f1)
#j2=$(echo $RESOLUTIONS | cut -d'x' -f2)
#j3=$(echo $RESOLUTIONS | cut -d'x' -f3)
#j4=$(echo $RESOLUTIONS | cut -d'x' -f4)
#
#AV_WIDTH=$j3
#AV_HEIGHT=$j4
## Desktop size
#WIDTH=$j1
#HEIGHT=$j2

# wmctrl -l -p -G -x
# wmctrl -r :ACTIVE: -p -G -x

# FIXME: Use ~/.cache/reputed-tiler/cycles/left|up|right|down
#
# M+Left → Use left-half of window.
# M+Left within 1 minute on same window ID → some nice floting size weighted top left
# M+Left, then M+Up within 1 min on same ID → 1/4 size topleft window
# M+Up not after M+Left or M+Right → top half of screen
# M+Up after top half of screen (or if already top half) → middle 1/3, top half; then cycle down?
#   and do opposite for M+Down repetition
#
#



  X_LEFT=$((0-($MARGIN_RIGHT+$OFFSET_X)))
  X_CENTER=$(($AV_WIDTH/2+$MARGIN_RIGHT+$MARGIN_LEFT))
  HALF_WIDTH=$X_CENTER
  Y_TOP=$((0-($MARGIN_TOP-$OFFSET_Y)))
  Y_CENTER=$(($Y_TOP+$HEIGHT/2))
  HALF_HEIGHT=$(($AV_HEIGHT/2+$MARGIN_TOP+$MARGIN_BOTTOM))
  SIZE=$HALF_WIDTH,$HALF_HEIGHT

  log "X_LEFT: ${X_LEFT} / X_CENTER: ${X_CENTER} / Y_TOP: ${Y_TOP} / Y_CENTER: ${Y_CENTER}"
  log "SIZE: ${SIZE}"

  local offsetgeo
  case "${direction}" in
    left)
      offsetgeo="$X_LEFT,$Y_TOP,$SIZE"
      ;;
    top)
      ;&
    up)
      offsetgeo="$X_CENTER,$Y_TOP,$SIZE"
      ;;
    right)
      offsetgeo="$X_LEFT,$Y_CENTER,$SIZE"
      ;;
    bottom)
      ;&
    down)
      offsetgeo="$X_CENTER,$Y_CENTER,$SIZE"
      ;;
    # ***
    topleft)
      offsetgeo="$X_LEFT,$Y_TOP,$SIZE"
      ;;
    topright)
      offsetgeo="$X_CENTER,$Y_TOP,$SIZE"
      ;;
    bottomleft)
      offsetgeo="$X_LEFT,$Y_CENTER,$SIZE"
      ;;
    bottomright)
      offsetgeo="$X_CENTER,$Y_CENTER,$SIZE"
      ;;
    # ***
    *)
      # Unreachable, because checked earlier, but included for completeness.
      >&2 echo "Unrecognized direction: “${direction}”"
      exit 2
      ;;
  esac
  log "offsetgeo: ${offsetgeo}"
  echo "${offsetgeo}"
}

# ***

reputed-tiler () {
  # Note: `local var=$(cmd)` always returns local's status of 0, so
  #       declare first, and then set it, as two separate operations.
  local direction
  direction=$(parse_first_positional "${@}") || return $?

  # First positional argument is empty if command already handled, e.g., -v, or -h, etc.
  [[ -z ${direction} ]] && return

  # Shake off ${direction}. Remainder is optional... and not used.
  shift

  must_be_known_direction "${direction}"

  local same_cmd_repeated_count
  same_cmd_repeated_count=$(read_last_used_direction "${direction}")
  log "same_cmd_repeated_count: ${same_cmd_repeated_count}"

  local offsetgeo
  offsetgeo=$(determine_offsetgeo "${direction}" "${same_cmd_repeated_count}")
  log "offsetgeo/2: ${offsetgeo}"

  CMD="wmctrl -r :ACTIVE: -e 0,${offsetgeo}"

  maybe_unset_maximized

  eval $($CMD)

#  record_last_used_direction "${direction}" "${same_cmd_repeated_count}" "${offsetgeo}"
  record_last_used_direction "${direction}" "${same_cmd_repeated_count}"
}

# ***

main () {
  log
  before_command
  if [[ ${BASH_SOURCE[0]} != "$0" ]]; then
    export -f reputed-tiler
  else
    reputed-tiler "${@}"
  fi
  after_command
}

main "${@}"

